[{"kind":2,"language":"ruby","value":"   def commitment(values, scope)\n      puts \"commitment: #{scope}, values: #{values}\"\n   end\n\n   def query_on_scope_field?(filter)\n    puts \"query_on_scope_field?: #{filter}\"\n    puts     filter.class\n\n    filter == :commitment\n   end\n\n   def use_service_method?(filter)\n    puts \"use_service_method?: #{filter}\"\n    respond_to?(filter, true)\n   end\n\n   def service_method(scope, (field, values))\n    send(field, values, scope)\n   end\n\n   def run_query_on_scope(scope, *args)\n    puts \"run_query_on_scope: #{scope}, #{args}\"\n   end\n\n   pr = proc do |*args|\n                puts  \"args: #{args}\"\n                case args\n                in [_, [Symbol => filter, _]] if query_on_scope_field?(filter) then run_query_on_scope(*args)\n                in [_, [Symbol => filter, _]] if use_service_method?(filter) then service_method(*args)\n                in [_, [Hash, _]] then filter_to_query[*args]\n                else raise ArgumentError, \"Unknown filter: #{filter}\"\n                end\n              end\n\n              {commitment: [line_item: [1,2,3,34]]}.reduce(1, &pr)\n\n              pr.call()\n\n"},{"kind":2,"language":"ruby","value":"class Events < Relations[:sql]\n  associte do \n    has_many :celis\n    belongs_to :change_reason\n  end\nend\n\nclass ChangeReason < Relations[:sql]\n  associte do \n    has_many :events\n    belogns_to :change_status\n  end\nend\n\nclass ChangeStatus < Relations[:sql]\n  associte do \n    has_many :change_reasons\n  end\nend\n\nclass Celi < Relations[:sql]\n  associte do \n    belongs_to :event\n    belongs_to :line_item\n  end\nend\n\nclass LineItem < Relations[:service]\n  associte do \n    has_one :celi\n  end\nend\n\nclass Order < Relations[:service]\n  associte do \n    has_many :line_items\n    belongs_to :stage\n  end\nend\n\nclass Stage < Relations[:service]\n  associte do \n    has_many :orders\n  end\nend\n"},{"kind":2,"language":"ruby","value":"class FilterRelationsVisitor\n  def visit(graph, conditions)\n    new_nodes = apply_conditions(graph.nodes, conditions)\n    graph.with(nodes: new_nodes)\n  end\n\n  private\n\n  def apply_conditions(nodes, conditions)\n    conditions.each_with_object(nodes.dup) do |(key, value), updated_nodes|\n      node = updated_nodes.assoc(key)&.last\n      next unless node\n\n      if value.is_a?(Hash)\n        updated_node = node.with(nodes: apply_conditions(node.nodes, value))\n      else\n        updated_filters = node.filters + [{ key => value }]\n        updated_node = node.with(filters: updated_filters)\n      end\n\n      updated_nodes[updated_nodes.index { |n| n.first == key }] = [key, updated_node]\n    end\n  end\nend"},{"kind":2,"language":"ruby","value":"require 'resources'\n\nrel3 = Resources::Relation::Graph.new(\n  relation: OpenStruct.new(relation_name: :change_reason),\n  meta: { join_keys: { change_reason_id: :id }, result: :one },\n  adapter: SqlAdapter.new\n)\n\nrel4 = Resources::Relation::Graph.new(\n  relation: OpenStruct.new(relation_name: :change_status),\n  meta: { join_keys: { change_status_id: :id }, result: :one },\n  adapter: ApiAdapter.new\n)\n\nrel1 = Resources::Relation::Graph.new(\n  relation: OpenStruct.new(relation_name: :celis),\n  meta: { join_keys: { event_id: :id }, result: :many },\n  nodes: { change_reason: rel3, change_status: rel4 },\n  adapter: SqlAdapter.new\n)\n\nrel2 = Resources::Relation::Graph.new(\n  relation: OpenStruct.new(relation_name: :orders),\n  meta: { join_keys: { order_id: :id }, result: :one },\n  nodes: { celis: rel1 },\n  adapter: SqlAdapter.new\n)\n\n# Apply where conditions\nvisitor = AlternativeFilterRelationsVisitor.new\nrel2 = visitor.visit(rel2, orders: { event_id: 1, celis: { change_reason_id: 2, change_status_id: 3 } })\nrel2 = visitor.visit(rel2, orders: { status: 'active' }, users: { blocked: false }, posts: { comments: { liked: true } })\n"},{"kind":2,"language":"ruby","value":"{a: :b}.last\n\n"},{"kind":2,"language":"ruby","value":" class DepartmentArRelationOne < Resources::Sql::Relation::ActiveRecord) \n          relation_name :department_one\n          table_name :departments\nend\nDepartmentArRelationOne::Datasource.table_name\n"},{"kind":2,"language":"ruby","value":"begin\n        connection.execute(datasource.to_sql).to_a\n  rescue => e\n    puts e.message\n    puts e.backtrace\nend"},{"kind":2,"language":"ruby","value":"# @param [...] args The forwarded arguments, which can include options and flags\ndef my_method(...)\n  puts \"Forwarded arguments: #{args.inspect}\"\n  # ...\nend\nmy_method(1, 2, 3, a: 1, b: 2)\n"},{"kind":2,"language":"ruby","value":"{a: {b: {c: :d}}}.values\n\n\n"}]